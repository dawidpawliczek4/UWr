### **Notatka do egzaminu â€“ WykÅ‚ad 12: Relacyjne Bazy Danych (1)**

---

## **1. Klasyfikacja baz danych**
Bazy danych moÅ¼na podzieliÄ‡ na kilka kategorii w zaleÅ¼noÅ›ci od sposobu przechowywania i przetwarzania danych.

### **1.1 Hierarchiczne bazy danych**
- Struktura **drzewiasta** (rodzic-dziecko).
- **Zalety**:
  - Proste i szybkie operacje dziÄ™ki hierarchicznej organizacji.
- **Wady**:
  - KaÅ¼dy wÄ™zeÅ‚ moÅ¼e mieÄ‡ tylko **jednego rodzica**.
  - Zmiana struktury moÅ¼e wymagaÄ‡ **przeprojektowania caÅ‚ej bazy**.
- **PrzykÅ‚ad**: Pliki **XML** jako forma bazy hierarchicznej.

---

### **1.2 Relacyjne bazy danych (RDB)**
- Dane sÄ… przechowywane w **tabelach** jako **wiersze i kolumny**.
- KaÅ¼da tabela posiada **klucz gÅ‚Ã³wny** (`PRIMARY KEY`) do identyfikacji wierszy.
- **Relacje** miÄ™dzy tabelami sÄ… definiowane przez **klucze obce** (`FOREIGN KEY`).
- **JÄ™zyk SQL** umoÅ¼liwia operacje na danych.

**PrzykÅ‚ady baz relacyjnych**:
- **Oracle Database**
- **Microsoft SQL Server**
- **MySQL**
- **PostgreSQL**

**Historia SQL**:
| Rok | Standard SQL | NowoÅ›ci |
|----|-------------|---------|
| 1986 | SQL-86 | Pierwsza wersja |
| 1992 | SQL-92 | Standard ISO 9075, kluczowe rozszerzenia |
| 1999 | SQL:1999 | Rekurencyjne zapytania, wyraÅ¼enia regularne |
| 2003 | SQL:2003 | ObsÅ‚uga XML, funkcje okna (`WINDOW`) |
| 2008 | SQL:2008 | `TRUNCATE`, `FETCH` |
| 2011 | SQL:2011 | Dane temporalne (`PERIOD FOR`) |
| 2016 | SQL:2016 | JSON, funkcje polimorficzne |

---

### **1.3 Obiektowe bazy danych**
- **Dane sÄ… przechowywane jako obiekty**, a nie jako wiersze i kolumny.
- **Brak potrzeby mapowania obiektowo-relacyjnego (ORM)**.
- **Zalety**:
  - Naturalne odwzorowanie w jÄ™zykach obiektowych (np. Java, C++).
- **Wady**:
  - ZwiÄ…zanie bazy z konkretnym jÄ™zykiem programowania.
  - Problemy z indeksowaniem i wydajnoÅ›ciÄ….
  - Rzadko stosowany jÄ™zyk zapytaÅ„ **OQL (Object Query Language)**.
- **PrzykÅ‚ady**: **db4o**, **ObjectDB**.

---

### **1.4 Bazy grafowe**
- **Dane sÄ… przechowywane jako wÄ™zÅ‚y i krawÄ™dzie** (grafy skierowane/nieskierowane).
- **Zastosowanie**:
  - Sieci spoÅ‚ecznoÅ›ciowe (np. **Facebook Graph API**).
  - Systemy rekomendacji.
- **JÄ™zyki zapytaÅ„**:
  - **Cypher (Neo4j)**.
  - **Gremlin (Apache TinkerPop)**.
- **PrzykÅ‚ady**:
  - **Neo4j**
  - **ArangoDB**

---

### **1.5 Bazy NoSQL**
- **Nie uÅ¼ywajÄ… SQL** do operacji na danych.
- **Rodzaje baz NoSQL**:
  - **Key-Value Stores** (np. Redis, Memcached).
  - **Document Stores** (np. MongoDB, CouchDB).
  - **Columnar Stores** (np. Apache Cassandra).
  - **Graph Stores** (np. Neo4j).
- **Zalety**:
  - **Lepsza skalowalnoÅ›Ä‡** niÅ¼ bazy relacyjne.
  - **Optymalizacja dla okreÅ›lonych zastosowaÅ„** (np. analiza duÅ¼ych zbiorÃ³w danych).
- **Wady**:
  - **Brak jednolitego standardu zapytaÅ„**.
  - **Problemy z modelowaniem danych** w bardziej skomplikowanych strukturach.

---

## **2. Podstawy relacyjnych baz danych**
Bazy relacyjne sÄ… oparte na **modelu matematycznym relacji**.

### **2.1 Podstawowe elementy bazy**
1. **Schematy i tabele** â€“ struktura bazy danych.
2. **Kolumny** â€“ okreÅ›lajÄ… typy danych (`INT`, `VARCHAR`, `BOOLEAN`, itp.).
3. **WartoÅ›ci NULL** â€“ oznaczajÄ… brak wartoÅ›ci w kolumnie.
4. **Klucze gÅ‚Ã³wne (`PRIMARY KEY`)** â€“ jednoznacznie identyfikujÄ… wiersze tabeli.
   - **Surrogate Key** â€“ klucz sztuczny (`ID` generowany automatycznie).
   - **Sekwencje** (`SEQUENCE`) â€“ generujÄ… wartoÅ›ci dla kluczy gÅ‚Ã³wnych.
5. **Klucze obce (`FOREIGN KEY`)** â€“ tworzÄ… relacje miÄ™dzy tabelami.
6. **Indeksy** â€“ przyspieszajÄ… wyszukiwanie danych.

---

### **2.2 Relacje miÄ™dzy tabelami**
- **Jeden-do-jeden (`1:1`)**:
  - Rzadka sytuacja, np. dodatkowe dane do istniejÄ…cego wiersza.
- **Jeden-do-wiele (`1:N`)**:
  - PrzykÅ‚ad: Klient â€“ ZamÃ³wienia.
- **Wiele-do-wiele (`N:M`)**:
  - Wymaga tabeli poÅ›redniczÄ…cej (`JOIN TABLE`).
- **Self-Join**:
  - Relacja wewnÄ…trz tej samej tabeli (np. drzewo kategorii).

---

### **2.3 Podstawowe zapytania SQL**
- **SELECT** â€“ pobieranie danych.
  ```sql
  SELECT * FROM Users;
  ```
- **INSERT** â€“ dodawanie danych.
  ```sql
  INSERT INTO Users (Name, Age) VALUES ('Jan', 30);
  ```
- **UPDATE** â€“ aktualizacja danych.
  ```sql
  UPDATE Users SET Age = 31 WHERE Name = 'Jan';
  ```
- **DELETE** â€“ usuniÄ™cie danych.
  ```sql
  DELETE FROM Users WHERE Name = 'Jan';
  ```
- **WHERE** â€“ warunek w zapytaniu.
  ```sql
  SELECT * FROM Users WHERE Age > 25;
  ```
- **ORDER BY** â€“ sortowanie wynikÃ³w.
  ```sql
  SELECT * FROM Users ORDER BY Age DESC;
  ```
- **GROUP BY + HAVING** â€“ grupowanie wynikÃ³w.
  ```sql
  SELECT Age, COUNT(*) FROM Users GROUP BY Age HAVING COUNT(*) > 1;
  ```
- **JOIN** â€“ Å‚Ä…czenie tabel.
  ```sql
  SELECT Orders.ID, Users.Name 
  FROM Orders 
  JOIN Users ON Orders.UserID = Users.ID;
  ```
- **LIMIT + OFFSET** â€“ stronicowanie wynikÃ³w.
  ```sql
  SELECT * FROM Users ORDER BY Name LIMIT 10 OFFSET 20;
  ```

---

## **3. PrzykÅ‚adowe zapytania do tabeli Parent-Child**
```sql
CREATE TABLE Parent (
    ID INT PRIMARY KEY IDENTITY(1,1),
    ParentName NVARCHAR(150) NOT NULL
);

CREATE TABLE Child (
    ID INT PRIMARY KEY IDENTITY(1,1),
    ChildName NVARCHAR(150) NOT NULL,
    ID_PARENT INT NOT NULL,
    CONSTRAINT FK_Child_Parent FOREIGN KEY (ID_PARENT) REFERENCES Parent(ID)
);
```
- **Dodanie rekordu**:
  ```sql
  INSERT INTO Parent (ParentName) VALUES ('Rodzic A');
  INSERT INTO Child (ChildName, ID_PARENT) VALUES ('Dziecko A', 1);
  ```
- **Wyszukanie wszystkich dzieci danego rodzica**:
  ```sql
  SELECT Parent.ParentName, Child.ChildName
  FROM Parent
  JOIN Child ON Parent.ID = Child.ID_PARENT;
  ```

---

## **Podsumowanie**
- **Bazy relacyjne dominujÄ… w aplikacjach biznesowych** ze wzglÄ™du na ustandaryzowany SQL.
- **Modele alternatywne (NoSQL, grafowe, obiektowe)** sÄ… uÅ¼ywane w specjalnych zastosowaniach.
- **SQL** pozwala na wydajne operacje dziÄ™ki indeksom, kluczom i optymalizacji zapytaÅ„.

NastÄ™pny temat: **Zaawansowane operacje SQL i optymalizacja zapytaÅ„!** ðŸš€